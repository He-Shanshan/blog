(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{272:function(a,r,n){"use strict";n.r(r);var _=n(0),v=Object(_.a)({},(function(){var a=this,r=a.$createElement,n=a._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"正则表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[a._v("#")]),a._v(" 正则表达式")]),a._v(" "),n("h2",{attrs:{id:"介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),n("p",[a._v("1.什么是正则表达式")]),a._v(" "),n("blockquote",[n("p",[a._v("正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。"),n("br"),a._v("\n2.常用的正则匹配工具"),n("br"),a._v("\n在线匹配工具：\n"),n("a",{attrs:{href:"http://rubular.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("rubular"),n("OutboundLink")],1),n("br"),a._v("\n正则匹配软件\n"),n("a",{attrs:{href:"https://pan.baidu.com/s/19Yn49",target:"_blank",rel:"noopener noreferrer"}},[a._v("McTracer百度云盘地址"),n("OutboundLink")],1),n("br"),a._v("\n支持将正则导成对应的语言如java C# js等，另外支持把正则表达式用法解释，如哪一段是捕获分组，哪段是贪婪匹配等等.")])]),a._v(" "),n("h2",{attrs:{id:"正则字符简单介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则字符简单介绍"}},[a._v("#")]),a._v(" 正则字符简单介绍")]),a._v(" "),n("p",[a._v("1.元字符介绍")]),a._v(" "),n("blockquote",[n("p",[a._v('"^" ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。'),n("br"),a._v('\n"$"  ：$会匹配行或字符串的结尾'),n("br"),a._v('\n"\\b" :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中"This is Regex"匹配单独的单词 "is" 正则就要写成 "\\bis\\b"'),n("br"),a._v("\n\\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界"),n("br"),a._v('\n"\\d": 匹配数字，'),n("br"),a._v('\n例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 这里只是为了介绍"\\d"字符，实际上有更好的写法会在下面介绍。'),n("br"),a._v('\n"\\w"：匹配字母，数字，下划线.'),n("br"),a._v('\n例如我要匹配"a2345BCD__TTz" 正则："\\w+"  这里的"+"字符为一个量词指重复的次数，稍后会详细介绍。'),n("br"),a._v('\n"\\s"：匹配空格'),n("br"),a._v('\n例如字符 "a b c" 正则："\\w\\s\\w\\s\\w"  一个字符后跟一个空格，如有字符间有多个空格直接把"\\s" 写成 "\\s +" 让空格重复'),n("br"),a._v('\n"."：匹配除了换行符以外的任何字符'),n("br"),a._v('\n这个算是"\\w"的加强版了"\\w"不能匹配 空格 如果把字符串加上空格用"\\w"就受限了，看下用 "."是如何匹配字符"a23 4 5 B C D__TTz"  正则：".+"'),n("br"),a._v('\n"[abc]": 字符组  匹配包含括号内元素的字符'),n("br"),a._v("\n这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，"),n("br"),a._v("\n2.几种反义"),n("br"),a._v("\n写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了"),n("br"),a._v('\n"\\W"   匹配任意不是字母，数字，下划线 的字符'),n("br"),a._v('\n"\\S"   匹配任意不是空白符的字符'),n("br"),a._v('\n"\\D"  匹配任意非数字的字符'),n("br"),a._v('\n"\\B"  匹配不是单词开头或结束的位置'),n("br"),a._v('\n"[^abc]"  匹配除了abc以外的任意字符'),n("br"),a._v("\n3.量词"),n("br"),a._v("\n先解释关于量词所涉及到的重要的三个概念"),n("br"),a._v('\n贪婪(贪心) 如"'),n("em",[a._v('"字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，'),n("br"),a._v('\n懒惰(勉强) 如 "?"  懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。'),n("br"),a._v('\n占有  如"+" 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金'),n("br"),a._v('\n"')]),a._v('"(贪婪)   重复零次或更多'),n("br"),a._v('\n例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a*"   会出到所有的字符"a"'),n("br"),a._v('\n"+"(懒惰)   重复一次或更多次'),n("br"),a._v('\n例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a+"  会取到字符中所有的a字符，  "a+"与"a*"不同在于"+"至少是一次而"*" 可以是0次，'),n("br"),a._v('\n稍后会与"?"字符结合来体现这种区别'),n("br"),a._v('\n"?"(占有)   重复零次或一次'),n("br"),a._v('\n例如"aaaaaaaa" 匹配字符串中的a 正则 ： "a?" 只会匹配一次，也就是结果只是单个字符a'),n("br"),a._v('\n"{n}"  重复n次'),n("br"),a._v('\n例如从"aaaaaaaa" 匹配字符串的a 并重复3次 正则：  "a{3}"  结果就是取到3个a字符  "aaa";'),n("br"),a._v('\n"{n,m}"  重复n到m次'),n("br"),a._v('\n例如正则 "a{3,4}" 将a重复匹配3次或者4次 所以供匹配的字符可以是三个"aaa"也可以是四个"aaaa" 正则都可以匹配到'),n("br"),a._v('\n"{n,}"  重复n次或更多次'),n("br"),a._v('\n与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则"a{3,}" a至少要重复3次\n把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 可以改为"^0\\d+-\\d{7}$"。'),n("br"),a._v('\n现在再改一下 "^0\\d{2,3}-\\d{7}"如此一来区号部分就可以匹配3位或者4位的了')])]),a._v(" "),n("h2",{attrs:{id:"正则进阶"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则进阶"}},[a._v("#")]),a._v(" 正则进阶")]),a._v(" "),n("p",[a._v("1.捕获分组"),n("br"),a._v('\n　　先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 "(\\d)\\d" 而"(\\d)" 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\\d)\\d\\1 这里的"\\1"就是对"(\\d)"的后向引用'),n("br"),a._v("\n那捕获分组有什么用呢看个例子就知道了"),n("br"),a._v('\n如  "zery zery" 正则 \\b(\\w+)\\b\\s\\1\\b 所以这里的"\\1"所捕获到的字符也是 与(\\w+)一样的"zery"，为了让组名更有意义，组名是可以自定义名字的'),n("br"),a._v(" "),n("code",[a._v("\\b(?<name>\\w+)\\b\\s\\k<name>\\b")]),a._v("用"),n("code",[a._v("?<name>")]),a._v("就可以自定义组名了而要后向引用组时要记得写成 "),n("code",[a._v("\\k<name>")]),a._v(";自定义组名后,捕获组中匹配到的值就会保存在定义的组名里"),n("br"),a._v("\n下面列出捕获分组常有的用法")]),a._v(" "),n("blockquote",[n("p",[a._v('"(exp)"    匹配exp,并捕获文本到自动命名的组里'),n("br"),a._v(" "),n("code",[a._v("(?<name>exp)")]),a._v("  匹配exp,并捕获文本到名称为name的组里"),n("br"),a._v('\n"(?:exp)"  匹配exp,不捕获匹配的文本，也不给此分组分配组号'),n("br"),a._v("\n以下为零宽断言"),n("br"),a._v('\n"(?=exp)"  匹配exp前面的位置'),n("br"),a._v('\n如 "How are you doing" 正则'),n("code",[a._v('"(?<txt>.+(?=ing))"')]),a._v('这里取ing前所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为'),n("code",[a._v('"How are you do"')]),a._v(";"),n("br"),a._v('\n"(?<=exp)"  匹配exp后面的位置'),n("br"),a._v('\n如 "How are you doing" 正则'),n("code",[a._v('"(?<txt>(?<=How).+)"')]),a._v('这里取"How"之后所有的字符，并定义了一个捕获分组名字为 "txt" 而"txt"这个组里的值为" are you doing";'),n("br"),a._v('\n"(?!exp)"  匹配后面跟的不是exp的位置'),n("br"),a._v('\n　　如 "123abc" 正则 "\\d{3}(?!\\d)"匹配3位数字后非数字的结果'),n("br"),a._v('\n"(?<!exp)"  匹配前面不是exp的位置'),n("br"),a._v('\n　　如 "abc123 " 正则 "(?<![0-9])123" 匹配"123"前面是非数字的结果也可写成"(?!<\\d)123"')])]),a._v(" "),n("h2",{attrs:{id:"未完待续"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#未完待续"}},[a._v("#")]),a._v(" 未完待续")])])}),[],!1,null,null,null);r.default=v.exports}}]);